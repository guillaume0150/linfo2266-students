package branchandbound;

import util.tsp.TSPInstance;

import java.util.*;


import java.util.concurrent.atomic.AtomicReference;

public class BranchAndBoundTSP {

    /**
     * Entry point for your Branch and Bound TSP Solver
     *
     * You must use the BrandAndBound class without modifying it (except possibly to compute the gap).
     * Have a look at @see {@link branchandbound.BranchAndBoundKnapsack} for an example.
     * As you will see, you have to implement your own State/Node class.
     *
     * You are free to choose your state representation.
     * This is part of the difficulty of the exercise.
     * Choose one representation that makes it easy to generate the successors of a node.
     *
     * @param instance an instance for the TSP
     * @param lbAlgo a lowe-bound algorithm for TSP
     * @return the list of edges in the optimal solution
     */
    public static List<Edge> optimize(TSPInstance instance, TSPLowerBound lbAlgo) {
        // TODO
         return null;
    }

    public static void main(String[] args) {
    }



}
